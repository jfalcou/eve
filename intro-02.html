<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>E.V.E: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="godbolt.js"></script>
<script type="text/javascript" src="fragment.js"></script>
<script type="text/javascript" src="paragraph.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
  DoxygenAwesomeFragmentCopyButton.init()
  SendToGodbolt.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/jfalcou/eve" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- BEGIN TITLEAREA-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr  style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">E.V.E
   </div>
   <div id="projectbrief">v2023.02.15</div>
  </td>
 </tr>
   <tr><td colspan="2" style="padding: 20px 0px 0px 0px;">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!--END TITLEAREA -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('intro-02.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Algorithms </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="intro-01.html">In the previous tutorial</a>, we managed to convert a sequential function into a function using SIMD types and functions. In general, such function is meant to be applied to a large set of data instead of a single register.</p>
<p>As for usual sequential computation, we want to lift ourselves from raw loops and think using algorithms. <b>EVE</b> provides such ready-to-use SIMD aware algorithms and this tutorial will take a look at how to handle them.</p>
<h1><a class="anchor" id="autotoc_md124"></a>
Initial problem</h1>
<p>Let's try to apply our sequential conversion function over data stored in <code>std::vector</code> using standard algorithms.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>scalar</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> all_rhos(std::vector&lt;float&gt; <span class="keyword">const</span>&amp; xs, std::vector&lt;float&gt; <span class="keyword">const</span>&amp; ys)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;float&gt; out(xs.size());</div>
<div class="line"> </div>
<div class="line">    std::transform( xs.begin(), xs.end(), ys.begin(), out.begin()</div>
<div class="line">                  , [](<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y) { return std::hypot(x, y); }</div>
<div class="line">                  );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Nothing really special here, we apply a given function over some <code>float</code> stored in a vector. Since C++20, you may be accustomed to the range-based version of this code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>scalar</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> all_rhos_range(std::vector&lt;float&gt; <span class="keyword">const</span>&amp; xs, std::vector&lt;float&gt; <span class="keyword">const</span>&amp; ys)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;float&gt; out(xs.size());</div>
<div class="line"> </div>
<div class="line">    std::ranges::transform( xs, ys, out.begin()</div>
<div class="line">                          , [](<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y) { return std::hypot(x, y); }</div>
<div class="line">                          );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Very similar code, except for the fact the input data are passed directly without using iterators.</p>
<h1><a class="anchor" id="autotoc_md125"></a>
Toward SIMD Algorithms</h1>
<p>We can turn this range-based code into a SIMD-aware call to one of the algorithms defined in eve::algo. All algorithms in <b>EVE</b> are range-based thus simplifying the transition from code using standard algorithms.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/math.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/algo.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>simd</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> all_rhos(std::vector&lt;float&gt; <span class="keyword">const</span>&amp; xs, std::vector&lt;float&gt; <span class="keyword">const</span>&amp; ys)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;float&gt; out(xs.size());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_variable" href="group__algos_ga023d457444697194cbb8dcf21bcb236e.html#ga023d457444697194cbb8dcf21bcb236e">eve::algo::transform_to</a> ( eve::views::zip(xs, ys), out</div>
<div class="line">                            , [](<span class="keyword">auto</span> xy)</div>
<div class="line">                              {</div>
<div class="line">                                <span class="keywordflow">return</span> <a class="code hl_variable" href="group__math__exp_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a>(get&lt;0&gt;(xy), get&lt;1&gt;(xy));</div>
<div class="line">                              }</div>
<div class="line">                            );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__algos_ga023d457444697194cbb8dcf21bcb236e_html_ga023d457444697194cbb8dcf21bcb236e"><div class="ttname"><a href="group__algos_ga023d457444697194cbb8dcf21bcb236e.html#ga023d457444697194cbb8dcf21bcb236e">eve::algo::transform_to</a></div><div class="ttdeci">constexpr auto transform_to</div><div class="ttdoc">SIMD version of std::transform.</div><div class="ttdef"><b>Definition:</b> transform.hpp:112</div></div>
<div class="ttc" id="agroup__math__exp_ga1f3f9f62c04251ff83111a058c2e64b9_html_ga1f3f9f62c04251ff83111a058c2e64b9"><div class="ttname"><a href="group__math__exp_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a></div><div class="ttdeci">constexpr auto hypot</div><div class="ttdoc">tuple_callable computing the  norm of its inputs.</div><div class="ttdef"><b>Definition:</b> hypot.hpp:88</div></div>
</div><!-- fragment --><p>Let's unpack all the new components:</p>
<ul>
<li>the SIMD algorithm used here is <a class="el" href="group__algos_ga023d457444697194cbb8dcf21bcb236e.html#ga023d457444697194cbb8dcf21bcb236e" title="SIMD version of std::transform.">eve::algo::transform_to</a> not just <code>eve::algo::transform</code>. This is due to the fact that discriminating operation between two distinct ranges and in-place operations leads to better code generation and performances. If you need to perform in-place computation, you can replace <a class="el" href="group__algos_ga023d457444697194cbb8dcf21bcb236e.html#ga023d457444697194cbb8dcf21bcb236e" title="SIMD version of std::transform.">eve::algo::transform_to</a> by <a class="el" href="group__algos_gabcfe49a76c53b5567df06523ded73cc0.html#gabcfe49a76c53b5567df06523ded73cc0" title="same as;">eve::algo::transform_inplace</a>, its in-place variant.</li>
<li><a class="el" href="group__algos_ga023d457444697194cbb8dcf21bcb236e.html#ga023d457444697194cbb8dcf21bcb236e" title="SIMD version of std::transform.">eve::algo::transform_to</a> takes a single input range. To pass multiple parallel ranges, we use eve::views::zip that constructs a view over them.</li>
<li>as we consume a zipped range, the data passed to the lambda function behaves like a tuple. We will dive into details of this tuple later but for now just remember you can retrieve the data member exactly like with a regular tuple (using <code>get</code> or structured bindings).</li>
</ul>
<h1><a class="anchor" id="autotoc_md126"></a>
Tuning algorithms</h1>
<p>In SIMD algorithms we by default assume that the provided operation is simple (a few instructions), since this is the common case. This means we use aligned reads and do unrolling, which is an important optimisation. However, for a complex case, like here, it is beneficial to opt out.</p>
<p><b>EVE</b> provides various traits to customize algorithms behavior. The traits we're interested in are:</p><ul>
<li><a class="el" href="group__algo__traits_ga244da44511b03c597243683208a3b731.html#ga244da44511b03c597243683208a3b731" title="NOTE: equivalent to no_aligning + no_unrolling + single_pass By default eve algorithms will assume th...">eve::algo::expensive_callable</a> - let's <b>EVE</b> know that the passed callable is fairly large. By default <b>EVE</b> will assume that the passed callables are cheap and it will align loads/stores, and unroll the loop body. There are also individual <code><a class="el" href="group__algo__traits_ga4e752623318f5d75907ed9f732c826a1.html#ga4e752623318f5d75907ed9f732c826a1" title="Traits for disabling alignment handling in algorithm.">eve::algo::no_aligning</a></code>, <code>eve::algo::unrolling</code></li>
<li><a class="el" href="group__algo__traits_ga1b9461ddb4574083563052a1fbe355e3.html#ga1b9461ddb4574083563052a1fbe355e3" title="You can find more explanations in the &#39;frequency scaling tutorial&#39;. On intel using 64 byte registers ...">eve::algo::allow_frequency_scaling</a> - tells <b>EVE</b> to use the maximum avaliable register size even if it can substentially temporary reduce processor's frequency. This only makes sense for really big arrays or if you spend most of your time doing simd operations. (At the moment this is only relevant for avx512). More details in frequency-scaling tutorial.</li>
</ul>
<p>Algorithms in <b>EVE</b> being callable object, you can apply traits using their <code>[]</code> operators. For example, the following code let's <b>EVE</b> know that the loop body is heavy.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/math.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/algo.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>simd::unrolled</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> all_rhos(std::vector&lt;float&gt; <span class="keyword">const</span>&amp; xs, std::vector&lt;float&gt; <span class="keyword">const</span>&amp; ys)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;float&gt; out(xs.size());</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_variable" href="group__algos_ga023d457444697194cbb8dcf21bcb236e.html#ga023d457444697194cbb8dcf21bcb236e">eve::algo::transform_to</a>[ <a class="code hl_variable" href="group__algo__traits_ga244da44511b03c597243683208a3b731.html#ga244da44511b03c597243683208a3b731">eve::algo::expensive_callable</a> ]</div>
<div class="line">                            ( eve::views::zip(xs, ys), out</div>
<div class="line">                            , [](<span class="keyword">auto</span> xy)</div>
<div class="line">                              {</div>
<div class="line">                                <span class="keywordflow">return</span> <a class="code hl_variable" href="group__math__exp_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a>(get&lt;0&gt;(xy), get&lt;1&gt;(xy));</div>
<div class="line">                              }</div>
<div class="line">                            );</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__algo__traits_ga244da44511b03c597243683208a3b731_html_ga244da44511b03c597243683208a3b731"><div class="ttname"><a href="group__algo__traits_ga244da44511b03c597243683208a3b731.html#ga244da44511b03c597243683208a3b731">eve::algo::expensive_callable</a></div><div class="ttdeci">constexpr auto expensive_callable</div><div class="ttdoc">NOTE: equivalent to no_aligning + no_unrolling + single_pass By default eve algorithms will assume th...</div><div class="ttdef"><b>Definition:</b> traits.hpp:267</div></div>
</div><!-- fragment --><p>Best strategy is always to benchmark your code and tune algorithms accordingly.</p>
<p>Note that this kind of tuning is not reserved to algorithms. The callable <code><a class="el" href="group__math__exp_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9" title="tuple_callable computing the  norm of its inputs.">eve::hypot</a></code> can also be tuned (here as <code><a class="el" href="group__math__exp_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9" title="tuple_callable computing the  norm of its inputs.">eve::hypot</a>[eve::pedantic]</code>) to enforce some behaviors regarding accuracy or standard compliance).</p>
<h1><a class="anchor" id="autotoc_md127"></a>
Conclusion</h1>
<p>In this tutorial, we managed to:</p><ul>
<li>use a simple algorithm from <b>EVE</b> algorithms set</li>
<li>use a range view to handle multiple inputs into our algorithm</li>
<li>work with SIMD tuple of data</li>
<li>tune algorithm using traits</li>
</ul>
<p><a class="el" href="intro-03.html">In the next tutorial</a>, we will complete this exercise by demonstrating how to use all elements seen this far to work directly on user-defined types. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.20-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</body>
</html>
