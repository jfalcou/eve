//==================================================================================================
/**
  EVE - Expressive Vector Engine
  Copyright : EVE Project Contributors
  SPDX-License-Identifier: BSL-1.0
**/
//==================================================================================================
#include "test.hpp"
#include "measures.hpp"
#include <eve/module/complex.hpp>
#include <eve/traits/common_value.hpp>


TTS_CASE_TPL( "Check corner cases of erf", eve::test::scalar::ieee_reals)
<typename T>(tts::type<T>)
{
  using c_t = eve::complex<T>;
  using eve::as;
  const int N = 18;
  auto zer = eve::zero(as<T>());
  auto inf = eve::inf(as<T>());
  auto nan = eve::nan(as<T>());
  auto one = eve::one(as<T>());
  std::array<c_t, N> inputs =
    {
      c_t(zer,zer), //0
      c_t(zer,inf), //1
      c_t(zer,nan), //2
      c_t(one,inf), //3
      c_t(one,nan), //4
      c_t(inf,zer), //5
      c_t(inf,one), //6
      c_t(inf,inf), //7
      c_t(inf,nan), //8
      c_t(nan,zer), //9
      c_t(nan,one), //10
      c_t(nan,nan), //11
      c_t(0.5, 0 ), //12
      c_t(0,  0.5), //13
      c_t(4e-2, 1),  //14
      c_t(4e-2, 1e-3), //15
      c_t(-4e-2, 1),  //16
      c_t(-4e-2, 1e-3)//17
    };

  std::array<c_t, N> results =
    {
      c_t(zer,zer),  //0
      c_t(zer, inf), //1
      c_t(zer,nan),  //2
      c_t(nan, nan), //3
      c_t(nan,nan),  //4
      c_t(1,zer),    //5
      c_t(1,zer),    //6
      c_t(nan, nan), //7
      c_t(nan,nan),  //8
      c_t(nan,zer),  //9
      c_t(nan,nan),  //10
      c_t(nan,nan),  //11
      c_t(5.204998778130465187e-01, 0), //12
      c_t(0, 6.14952094696510909e-01), //13
      c_t(1.224939980392529826e-01, 1.645524692691958002e+00), //14
      c_t(4.511115120815541862e-02, 1.126575578306994625e-03), //15
      c_t(-1.224939980392529826e-01, 1.645524692691958002e+00), //16
      c_t(-4.511115120815541862e-02, 1.126575578306994625e-03) //17
    };
  using eve::conj;
  using eve::erf;
  for(int i=0; i < N; ++i)
  {
    TTS_ULP_EQUAL(erf(inputs[i]), results[i], 52);
    TTS_IEEE_EQUAL(erf(conj(inputs[i])), conj(erf(inputs[i])));
  }
};

TTS_CASE_TPL( "Check corner cases of erf", eve::test::scalar::ieee_reals)
  <typename T>(tts::type<T>)
{
  using c_t = eve::complex<T>;
  using eve::as;
  auto inf = eve::inf(as<T>());
  auto nan = eve::nan(as<T>());
  constexpr int NTST = 41;
  c_t z[NTST] = {
    c_t(1,2), //0
    c_t(-1,2), //1
    c_t(1,-2), //2
    c_t(-1,-2), //3
    c_t(9,-28), //4
    c_t(21,-33), //5
    c_t(1e3,1e3), //6
    c_t(-3001,-1000), //7
    c_t(1e20, -1e19),//8
    c_t(5.1e-3, 1e-8), //9
    c_t(-4.9e-3, 4.95e-3), //10
    c_t(4.9e-3, 0.5), //11
    c_t(4.9e-4, -0.5e1), //12
    c_t(-4.9e-5, -0.5e2),//13
    c_t(5.1e-3, 0.5),//14
    c_t(5.1e-4, -0.5e1),//15
    c_t(-5.1e-5, -0.5e2),//16
    c_t(1e-6,2e-6),//17
    c_t(0,2e-6),//18
    c_t(0,2),//19
    c_t(0,20),//20
    c_t(0,200),//21
    c_t(inf,0),//22
    c_t(-inf,0),//23
    c_t(0,inf),//24
    c_t(0,-inf),//25
    c_t(inf,inf),//26
    c_t(inf,-inf),//27
    c_t(nan,nan),//28
    c_t(nan,0),//29
    c_t(0,nan),//30
    c_t(nan,inf),//31
    c_t(inf,nan),//32
    c_t(1e-3,nan),//33
    c_t(7e-2,7e-2),//34
    c_t(7e-2,-7e-4),//35
    c_t(-9e-2,7e-4),//36
    c_t(-9e-2,9e-2),//37
    c_t(-7e-4,9e-2),  //38
    c_t(7e-2,0.9e-2), //39
    c_t(7e-2,1.1e-2) //40
  };
  c_t w[NTST] = { // erf(z[i]), evaluated with Maple
    c_t(-0.5366435657785650339917955593141927494421,
        -5.049143703447034669543036958614140565553), //0
    c_t(0.5366435657785650339917955593141927494421,
        -5.049143703447034669543036958614140565553), //1
    c_t(-0.5366435657785650339917955593141927494421,
        5.049143703447034669543036958614140565553), //2
    c_t(0.5366435657785650339917955593141927494421,
        5.049143703447034669543036958614140565553), //3
    c_t(0.3359473673830576996788000505817956637777e304,
        -0.1999896139679880888755589794455069208455e304), //4
    c_t(0.3584459971462946066523939204836760283645e278,
        0.3818954885257184373734213077678011282505e280), //5
    c_t(0.9996020422657148639102150147542224526887,
        0.00002801044116908227889681753993542916894856), //6
    c_t(-1, 0),//7
    c_t(1, 0),//8
    c_t(0.005754683859034800134412990541076554934877,
        0.1128349818335058741511924929801267822634e-7),//9
    c_t(-0.005529149142341821193633460286828381876955,
        0.005585388387864706679609092447916333443570),//10
    c_t(0.007099365669981359632319829148438283865814,
        0.6149347012854211635026981277569074001219),//11
    c_t(0.3981176338702323417718189922039863062440e8,
        -0.8298176341665249121085423917575122140650e10),//12
    c_t(-inf,
        -inf), //13
    c_t(0.007389128308257135427153919483147229573895,
        0.6149332524601658796226417164791221815139),
    c_t(0.4143671923267934479245651547534414976991e8,
        -0.8298168216818314211557046346850921446950e10),
    c_t(-inf,
        -inf),
    c_t(0.1128379167099649964175513742247082845155e-5,
        0.2256758334191777400570377193451519478895e-5),
    c_t(0,
        0.2256758334194034158904576117253481476197e-5),
    c_t(0,
        18.56480241457555259870429191324101719886),
    c_t(0,
        0.1474797539628786202447733153131835124599e173),
    c_t(0,
        inf),
    c_t(1,0),
    c_t(-1,0),
    c_t(0,inf),
    c_t(0,-inf),
    c_t(nan,nan),
    c_t(nan,nan),
    c_t(nan,nan),
    c_t(nan,0),
    c_t(0,nan),
    c_t(nan,nan),
    c_t(nan,nan),
    c_t(nan,nan),
    c_t(0.07924380404615782687930591956705225541145,
        0.07872776218046681145537914954027729115247),
    c_t(0.07885775828512276968931773651224684454495,
        -0.0007860046704118224342390725280161272277506),
    c_t(-0.1012806432747198859687963080684978759881,
        0.0007834934747022035607566216654982820299469),
    c_t(-0.1020998418798097910247132140051062512527,
        0.1010030778892310851309082083238896270340),
    c_t(-0.0007962891763147907785684591823889484764272,
        0.1018289385936278171741809237435404896152),
    c_t(0.07886408666470478681566329888615410479530,
        0.01010604288780868961492224347707949372245),
    c_t(0.07886723099940260286824654364807981336591,
        0.01235199327873258197931147306290916629654)
  };
  using eve::erf;
  using eve::conj;
  using TT = eve::wide < c_t, eve::fixed<4>>;
  for(int i=0; i < NTST; ++i)
  {
    TTS_ULP_EQUAL(erf(z[i]), w[i], 2000) << "i " << i << " -> " << z[i] <<  " -> " <<erf(z[i]) <<  " -> " <<w[i] <<"\n";
    TTS_RELATIVE_EQUAL(erf(z[i]), w[i], 1.0e-4) << "i " << i << '\n';
    TTS_ULP_EQUAL(erf(-z[i]), -w[i], 2000) << "i " << i << '\n';


    TTS_ULP_EQUAL(erf(TT(z[i])), TT(w[i]), 2000)<< "i " << i << " -> " << z[i] <<  " -> " <<erf(z[i]) <<  " -> " <<w[i] <<"\n";
    TTS_RELATIVE_EQUAL(erf(TT(z[i])), TT(w[i]), 1.0e-4) << "i " << i << '\n';
    TTS_ULP_EQUAL(erf(-z[i]), -w[i], 2000);
  }
};

TTS_CASE_WITH( "Check behavior of erf on wide"
             , eve::test::simd::ieee_reals
             , tts::generate( tts::randoms(-10.0, 10.0)
                            , tts::randoms(-10.0, 10.0))
        )
  <typename T>(T const& a0, T const& a1 )
{
  using z_t = eve::as_complex_t<T>;
  using e_t = eve::element_type_t<T>;
  using c_t = eve::complex<e_t>;
  auto z = z_t(a0, a1);
  auto ez = eve::erf(z);
  c_t b;
  for(int i = 0; i !=  eve::cardinal_v<T>; ++i)
  {
    TTS_ULP_EQUAL(ez.get(i), eve::erf(z.get(i)), 1000.0);
  }
};
