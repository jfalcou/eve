##==================================================================================================
##  EVE - Expressive Vector Engine
##  Copyright 2019 Joel FALCOU
##  Copyright 2019 Jean-Thierry Lapreste
##
##  Licensed under the MIT License <http://opensource.org/licenses/MIT>.
##  SPDX-License-Identifier: MIT
##==================================================================================================
##==================================================================================================
## Setup aggregation of tests
##==================================================================================================
add_custom_target(exhaustive.core.exe)
add_custom_target(exhaustive.core.scalar.exe)
add_custom_target(exhaustive.core.simd.exe)
add_dependencies(exhaustive.core.exe exhaustive.core.scalar.exe)
add_dependencies(exhaustive.core.exe exhaustive.core.simd.exe)
add_dependencies(exhaustive.scalar.exe exhaustive.core.scalar.exe)
add_dependencies(exhaustive.simd.exe exhaustive.core.simd.exe)
add_dependencies(exhaustive.exe exhaustive.core.exe)

##==================================================================================================
## Elementwise function unit tests
##==================================================================================================
make_all_units(ROOT exhaustive.core NAME abs                   ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME arg                   ARCH scalar simd TYPES ${real_types_32}    )
##make_all_units(ROOT exhaustive.core NAME bit_cast              ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME bit_ceil              ARCH scalar simd TYPES ${uint_or_real_types_32})
make_all_units(ROOT exhaustive.core NAME bit_floor             ARCH scalar simd TYPES ${uint_or_real_types_32})
##make_all_units(ROOT exhaustive.core NAME bit_mask              ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME bit_mantissa          ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME bit_not               ARCH scalar simd TYPES ${integral_types_32}     )
make_all_units(ROOT exhaustive.core NAME bit_width             ARCH scalar simd TYPES ${uint_types_32}    )
make_all_units(ROOT exhaustive.core NAME cbrt                  ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME ceil                  ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME conj                  ARCH scalar simd TYPES ${real_types_32}    )
##make_all_units(ROOT exhaustive.core NAME convert               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME countl_one            ARCH scalar simd TYPES ${uint_types_32}    )
##make_all_units(ROOT exhaustive.core NAME countl_zero           ARCH scalar simd TYPES ${uint_types_32}    )
##make_all_units(ROOT exhaustive.core NAME countr_one            ARCH scalar simd TYPES ${uint_types_32}    )
##make_all_units(ROOT exhaustive.core NAME countr_zero           ARCH scalar simd TYPES ${uint_types_32}    )
##make_all_units(ROOT exhaustive.core NAME dec                   ARCH scalar simd TYPES ${all_types_32}     )
##make_all_units(ROOT exhaustive.core NAME dist                  ARCH scalar simd TYPES ${all_types_32}     )
##make_all_units(ROOT exhaustive.core NAME div                   ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME exponent              ARCH scalar simd TYPES ${real_types_32}    )
##make_all_units(ROOT exhaustive.core NAME fdim                  ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME firstbitset           ARCH scalar simd TYPES ${integral_types_32})
make_all_units(ROOT exhaustive.core NAME firstbitunset         ARCH scalar simd TYPES ${integral_types_32})
make_all_units(ROOT exhaustive.core NAME floor                 ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME frac                  ARCH scalar simd TYPES ${all_types_32}     )
####make_all_units(ROOT exhaustive.core NAME frexp                 ARCH scalar simd TYPES ${real_types_32}    )
##make_all_units(ROOT exhaustive.core NAME has_single_bit        ARCH scalar simd TYPES ${integral_types_32})
##make_all_units(ROOT exhaustive.core NAME iceil                 ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME ifloor                ARCH scalar simd TYPES ${all_types_32}     )
####make_all_units(ROOT exhaustive.core NAME ifrexp                ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME inc                   ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME inearest              ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME iround                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_denormal           ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_eqz                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_even               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_finite             ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_flint              ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_gez                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_gtz                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_imag               ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME is_infinite           ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_lez                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_ltz                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_nan                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_negative           ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_nez                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_ngez               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_ngtz               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_nlez               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_nltz               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_normal             ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_not_denormal       ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_not_equal          ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_not_finite         ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_not_imag           ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME is_not_infinite       ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_not_nan            ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_not_real           ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME is_odd                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_ordered            ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_positive           ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME is_pow2               ARCH scalar simd TYPES ${integral_types_32})
make_all_units(ROOT exhaustive.core NAME is_real               ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME itrunc                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME logical_not           ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME mantissa              ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME minus                 ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME nearest               ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME next                  ARCH scalar simd TYPES ${all_types_32}     )
##make_all_units(ROOT exhaustive.core NAME nextafter             ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME oneminus              ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME plus                  ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME popcount              ARCH scalar simd TYPES ${integral_types_32})
make_all_units(ROOT exhaustive.core NAME prev                  ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME rec                   ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME round                 ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME rsqrt                 ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME saturate              ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME sign                  ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME signnz                ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME sqr                   ARCH scalar simd TYPES ${all_types_32}     )
make_all_units(ROOT exhaustive.core NAME sqr_abs               ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME sqrt                  ARCH scalar simd TYPES ${real_types_32}    )
make_all_units(ROOT exhaustive.core NAME trunc                 ARCH scalar simd TYPES ${all_types_32}     )
