<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="generator" content="Doxygen 1.9.4"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>E.V.E: SIMD Basic Operations</title>
  <!--<link href="tabs.css" rel="stylesheet" type="text/css"/> REMOVED BY DOXYSTRAP -->
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="godbolt.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxystrap.css" rel="stylesheet" type="text/css"/>
  <!-- DOXYSTRAP BLOCK CHANGE BEGIN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
  <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
  <script type="text/javascript" src="doxystrap.js"></script>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <!-- Optional theme -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
  <!-- Latest compiled and minified JavaScript -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <!-- Custom input to switch branches -->
  <script>
    function switchBranchAction() {
      var branch = document.getElementById("branch_input").value;
      var form = this;
      window.location.href = window.location.hostname + '/en/' + branch;
    }
  </script>
  <!-- DOXYSTRAP BLOCK CHANGE END -->
</head>
<body>
  <!-- DOXYSTRAP BLOCK CHANGE BEGIN -->
  <nav class="navbar navbar-default" role="navigation">
    <div class="container">
      <div class="navbar-header">
      <!--GITHUB RIBBON-->
      <a id="forkme_banner" href="https://github.com/jfalcou/eve">View on GitHub</a>
      <!--GITHUB RIBBON-->
        <a href="index.html" class="navbar-brand">E.V.E v2021.10.0</a>
      </div>
    </div>
  </nav>
  <!-- DOXYSTRAP BLOCK CHANGE END -->
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <!-- DOXYSTRAP BLOCK CHANGE BEGIN -->
    <div class="content" id="content">
      <div class="container">
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr style="height: 56px;">
                <td id="projectlogo"><a href="index.html"><img alt="Logo" src="logo.png" /></a>
                </td>
                <td id="projectalign" style="padding-left: 0.5em;">
                  <div id="projectname">E.V.E
                    &#160;<span id="projectnumber">v2021.10.0</span>
                  </div>
                  <!-- BEGIN PROJECT_BRIEF--><div id="projectbrief">The Expressive Vector Engine</div><!--END PROJECT_BRIEF -->
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="row">
          <div class="col-sm-12 panel " style="padding-bottom: 15px;">
            <div style="margin-bottom: 15px;">
              <!-- DOXYSTRAP BLOCK CHANGE END -->
              <!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Index</span></a></li>
      <li class="current"><a href="pages.html"><span>Documentation</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>References</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="pages.html"><span>Documentation</span></a></li>
      <li><a href="about.html"><span>Getting&#160;Started</span></a></li>
      <li><a href="tutorials.html"><span>Tutorials</span></a></li>
      <li><a href="rationale.html"><span>Rationale</span></a></li>
      <li><a href="eve-dev.html"><span>Contributing</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li><li class="navelem"><a class="el" href="simd-101.html">SIMD 101</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">SIMD Basic Operations </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md2048">Initial problem</a></li>
<li class="level2"><a href="#autotoc_md2049">From scalar to SIMD using eve::wide</a></li>
<li class="level2"><a href="#autotoc_md2050">Handling eve::wide</a></li>
<li class="level2"><a href="#autotoc_md2051">Mathematical Epilogue</a></li>
<li class="level2"><a href="#autotoc_md2052">Conclusion</a></li>
</ul>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="autotoc_md2048"></a>
Initial problem</h2>
<p >Let's say we want to convert 2D cartesian coordinates to 2D polar coordinates. This is a rather common exercise and will only require basic arithmetic and trigonometric functions.</p>
<p >Cartesian coordinates are usually represented by a pair of floating point values \((x,y)\). In a similar way, polar coordinate can be represented as a pair \((\rho,\theta)\) where \(\rho\) represents the length of the ray and \(\theta\) represents the angle with the X axis.</p>
<p >A bit of geometry in the unit circle leads to a relationship between the cartesian and the polar coordinates :</p>
<center> <a href="https://commons.wikimedia.org/wiki/File:Polar_coordinate_components.svg" title="WillowW, CC BY-SA 3.0 &amp;lt;https://creativecommons.org/licenses/by-sa/3.0&amp;gt;, via Wikimedia Commons"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Polar_coordinate_components.svg/512px-Polar_coordinate_components.svg.png" alt="Polar coordinate components" width="23%" class="center" class="inline"/> </a> </center><div class="fragment"><div class="line"> </div>
</div><!-- fragment --><p >Therefore, we can derive the following C++ functions that perform this conversion:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> rho(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="group__core_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">std::sqrt</a>(x * x + y * y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> theta(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="group__math_gaa4476e86ad2d63ed1ee057fb3bc30354.html#gaa4476e86ad2d63ed1ee057fb3bc30354">std::atan2</a>(y, x);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core_ga6745422ee3727af1a6e34182e8efbcb7_html_ga6745422ee3727af1a6e34182e8efbcb7"><div class="ttname"><a href="group__core_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">eve::sqrt</a></div><div class="ttdeci">constexpr callable_sqrt_ sqrt</div><div class="ttdoc">Callable object computing the square root.</div><div class="ttdef"><b>Definition:</b> sqrt.hpp:99</div></div>
<div class="ttc" id="agroup__math_gaa4476e86ad2d63ed1ee057fb3bc30354_html_gaa4476e86ad2d63ed1ee057fb3bc30354"><div class="ttname"><a href="group__math_gaa4476e86ad2d63ed1ee057fb3bc30354.html#gaa4476e86ad2d63ed1ee057fb3bc30354">eve::atan2</a></div><div class="ttdeci">constexpr callable_atan2_ atan2</div><div class="ttdoc">Callable object computing the atan2 operation.</div><div class="ttdef"><b>Definition:</b> atan2.hpp:94</div></div>
</div><!-- fragment --><p >As expected, the code only requires arithmetic operations and some trigonometry. Fellow mathematicians in the audience may have some remarks on this code. For now, we will deal with the fact that it requires \(\theta\) to be in radians and that the accuracy of computing \(\rho\) this way is maybe sub-optimal. We will address those concerns later.</p>
<h2><a class="anchor" id="autotoc_md2049"></a>
From scalar to SIMD using eve::wide</h2>
<p >The next step is to work a SIMD version of those functions. When dealing with SIMD data types, one has to remember that a single operation has to be performed on multiple values. There, we will be working on multiple <code>x</code>and <code>y</code> to computes multiple \(\rho\) and \(\theta\).</p>
<p >SIMD instructions sets provides architecture-specific types for SIMD register along with ISA specific functions. Of course, handling such types and functions is highly non-portable. To overcome this issue, <b>EVE</b> provides a generic, architecture agnostic type for SIMD computation: <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>.</p>
<p >As <b>EVE</b> provides SIMD implementation of all basic operators and all the common math functions (among others), the conversion from scalar to SIMD is done by:</p><ul>
<li>including the proper header files</li>
<li>replacing <code>float</code> with <code><a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>&lt;float&gt;</code></li>
<li>calling function from namespace <code>eve</code> instead of <code>std</code>.</li>
</ul>
<p >The SIMD version of our conversion functions are then given by:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;eve/wide.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/math.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> rho(<a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x, <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span>  <a class="code hl_variable" href="group__core_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">eve::sqrt</a>(x * x + y * y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> theta(<a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x, <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="group__math_gaa4476e86ad2d63ed1ee057fb3bc30354.html#gaa4476e86ad2d63ed1ee057fb3bc30354">eve::atan2</a>(y, x);</div>
<div class="line">}</div>
<div class="ttc" id="astructeve_1_1wide_html"><div class="ttname"><a href="structeve_1_1wide.html">eve::wide</a></div><div class="ttdoc">Wrapper for SIMD registers.</div><div class="ttdef"><b>Definition:</b> wide.hpp:62</div></div>
</div><!-- fragment --><p ><a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> behaves like a regular type and can just be dropped as a replacement for any C++ arithmetic types.</p>
<h2><a class="anchor" id="autotoc_md2050"></a>
Handling eve::wide</h2>
<p >The remaining question is how to put data inside an instance of <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> so we can write tests for our SIMD cartesian to polar conversion function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> check_polar()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x1{4};</div>
<div class="line">  <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y1{[](<span class="keyword">auto</span> i, auto ) { <span class="keywordflow">return</span> 1.5f*(i+1); }};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; x1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y1 &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; rho(x1,y1) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">float</span> data[] = {1.5f, 3, 4.5f, 6, 7.5f, 9, 10.5f, 12, 13.5, 15, 16.5, 18, 19.5, 21, 22.5, 24};</div>
<div class="line">  <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y2{&amp;data[0]};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; x1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y2 &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; theta(x1,y2) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >There, we construct three instances of <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> using three different constructors:</p>
<ul>
<li><code>x1</code> is constructed from a single scalar value. The result is a register with a 4 in every lane.</li>
<li><code>y1</code> is constructed from a callable object taking two parameters. The first parameter is the current lane to compute, the second is the actual width of the register. The callable object is called once per lane with the corresponding lane index. Here, we use a lambda function that store <code>1.5 * (1 + i)</code> in the \(i^{th}\) lane.</li>
<li><code>y2</code> is constructed from a pointer to <code>float</code>. This will perform a memory-to-register transfer and read <code><a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>&lt;float&gt;::size()</code> contiguous elements starting from <code>&amp;data[0]</code>.</li>
</ul>
<p >An important detail is to note that neither the <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> type nor any of those constructors requires an <em>a priori</em> knowledge of the actual CPU architecture nor the actual number of lane in the register. This architecture-agnostic style is the main advantage of <b>EVE</b> as it guarantees the portability of the code.</p>
<p >Let's compile this small test using g++:</p>
<div class="fragment"><div class="line">g++ intro-01.cpp -O3 -DNDEBUG -I/path/to/<a class="code hl_namespace" href="namespaceeve.html">eve</a></div>
<div class="ttc" id="anamespaceeve_html"><div class="ttname"><a href="namespaceeve.html">eve</a></div><div class="ttdoc">Main EVE namespace.</div><div class="ttdef"><b>Definition:</b> all_of.hpp:24</div></div>
</div><!-- fragment --><p >By default, if you're compiling on a Intel X86_64 machine, the SSE2 SIMD extension set will be used by the compiler. Under SSE2, SIMD register of <code>float</code> have four lanes. So the expected result is:</p>
<div class="fragment"><div class="line">(4, 4, 4, 4) (1.5, 3, 4.5, 6) =&gt; (4.272, 5, 6.0208, 7.2111)</div>
<div class="line">(4, 4, 4, 4) (1.5, 3, 4.5, 6) =&gt; (0.358771, 0.643501, 0.844154, 0.982794)</div>
</div><!-- fragment --><p >But what if we want to use a SIMD extension with larger registers, say AVX2 for example? In this case, you need to pass the appropriate option to your compiler. For g++, this means using <code>-mavx2</code>.</p>
<div class="fragment"><div class="line">g++ intro-01.cpp -O3 -DNDEBUG -mavx2 -I/path/to/<a class="code hl_namespace" href="namespaceeve.html">eve</a></div>
</div><!-- fragment --><p >As AVX2 registers are twice as big, the output should now contains 8 values:</p>
<div class="fragment"><div class="line">(4, 4, 4, 4, 4, 4, 4, 4) (1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12) =&gt; (4.272, 5, 6.0208, 7.2111, 8.5, 9.84886, 11.2361, 12.6491)</div>
<div class="line">(4, 4, 4, 4, 4, 4, 4, 4) (1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12) =&gt; (0.358771, 0.643501, 0.844154, 0.982794, 1.08084, 1.15257, 1.20682, 1.24905)</div>
</div><!-- fragment --><p >As expected, <b>EVE</b> code scales naturally with the selected architecture at compile time.</p>
<h2><a class="anchor" id="autotoc_md2051"></a>
Mathematical Epilogue</h2>
<p >As stated earlier, we are currently using a slightly brutal computation for \(\rho\). Indeed, if the magnitudes of <code>x</code> and <code>y</code> vary greatly, we may end up with overflow or cancellation, both classic IEEE 754 floating-point issues.</p>
<p >Computing the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation is the job of a very specific function: <code>std::hypot</code>. Quite handily, <b>EVE</b> also proposes a SIMD implementation via <a class="el" href="group__math_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9" title="Callable object computing the hypot operation.">eve::hypot</a>.</p>
<p >A better implementation is then given as:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;eve/wide.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/math.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> better_rho(<a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x, <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span>  <a class="code hl_variable" href="group__math_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a>(x, y);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__math_ga1f3f9f62c04251ff83111a058c2e64b9_html_ga1f3f9f62c04251ff83111a058c2e64b9"><div class="ttname"><a href="group__math_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a></div><div class="ttdeci">constexpr callable_hypot_ hypot</div><div class="ttdoc">Callable object computing the hypot operation.</div><div class="ttdef"><b>Definition:</b> hypot.hpp:92</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2052"></a>
Conclusion</h2>
<p >In this first tutorial, we managed to:</p><ul>
<li>get familiar with <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>, the main SIMD enabling type from <b>EVE</b></li>
<li>take a simple scalar operation and turn it into a SIMD function using <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a></li>
<li>compile the code for various platform and checks the results.</li>
<li>be aware of the architecture agnostic style of coding with <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a></li>
</ul>
<p ><a class="el" href="intro-02.html">In the next tutorial</a>, we will use this SIMD function as it should by applying it over multiple data. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.20-->
<!-- start footer part -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
<hr class="footer"/>
</body>
</html>
