<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>E.V.E: Basic Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="godbolt.js"></script>
<script type="text/javascript" src="fragment.js"></script>
<script type="text/javascript" src="paragraph.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
  DoxygenAwesomeFragmentCopyButton.init()
  SendToGodbolt.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/jfalcou/eve" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- BEGIN TITLEAREA-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr  style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">E.V.E
   </div>
   <div id="projectbrief">v2022.03.00</div>
  </td>
 </tr>
   <tr><td colspan="2" style="padding: 20px 0px 0px 0px;">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!--END TITLEAREA -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('intro-01.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Basic Operations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md2238"></a>
Initial problem</h1>
<p >Let's say we want to convert 2D cartesian coordinates to 2D polar coordinates. This is a rather common exercise and will only require basic arithmetic and trigonometric functions.</p>
<p >Cartesian coordinates are usually represented by a pair of floating point values \((x,y)\). In a similar way, polar coordinate can be represented as a pair \((\rho,\theta)\) where \(\rho\) represents the length of the ray and \(\theta\) represents the angle with the X axis.</p>
<p >A bit of geometry in the unit circle leads to a relationship between the cartesian and the polar coordinates :</p>
<center> <a href="https://commons.wikimedia.org/wiki/File:Polar_coordinate_components.svg" title="WillowW, CC BY-SA 3.0 https://creativecommons.org/licenses/by-sa/3.0, via Wikimedia Commons"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Polar_coordinate_components.svg/512px-Polar_coordinate_components.svg.png" alt="Polar coordinate components" width="30%" class="center" class="inline"/> </a> </center><p >Therefore, we can derive the following C++ functions that perform this conversion:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> rho(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="group__core_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">std::sqrt</a>(x * x + y * y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> theta(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="group__math_gaa4476e86ad2d63ed1ee057fb3bc30354.html#gaa4476e86ad2d63ed1ee057fb3bc30354">std::atan2</a>(y, x);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core_ga6745422ee3727af1a6e34182e8efbcb7_html_ga6745422ee3727af1a6e34182e8efbcb7"><div class="ttname"><a href="group__core_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">eve::sqrt</a></div><div class="ttdeci">constexpr callable_sqrt_ sqrt</div><div class="ttdoc">Callable object computing the square root.</div><div class="ttdef"><b>Definition:</b> sqrt.hpp:98</div></div>
<div class="ttc" id="agroup__math_gaa4476e86ad2d63ed1ee057fb3bc30354_html_gaa4476e86ad2d63ed1ee057fb3bc30354"><div class="ttname"><a href="group__math_gaa4476e86ad2d63ed1ee057fb3bc30354.html#gaa4476e86ad2d63ed1ee057fb3bc30354">eve::atan2</a></div><div class="ttdeci">constexpr callable_atan2_ atan2</div><div class="ttdoc">Callable object computing the atan2 operation.</div><div class="ttdef"><b>Definition:</b> atan2.hpp:94</div></div>
</div><!-- fragment --><p >As expected, the code only requires arithmetic operations and some trigonometry. Fellow mathematicians in the audience may have some remarks on this code. For now, we will deal with the fact that it requires \(\theta\) to be in radians and that the accuracy of computing \(\rho\) this way is maybe sub-optimal. We will address those concerns later.</p>
<h1><a class="anchor" id="autotoc_md2239"></a>
From scalar to SIMD using eve::wide</h1>
<p >The next step is to work a SIMD version of those functions. When dealing with SIMD data types, one has to remember that a single operation has to be performed on multiple values. There, we will be working on multiple <code>x</code>and <code>y</code> to computes multiple \(\rho\) and \(\theta\).</p>
<p >SIMD instructions sets provides architecture-specific types for SIMD register along with ISA specific functions. Of course, handling such types and functions is highly non-portable. To overcome this issue, <b>EVE</b> provides a generic, architecture agnostic type for SIMD computation: <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>.</p>
<p >As <b>EVE</b> provides SIMD implementation of all basic operators and all the common math functions (among others), the conversion from scalar to SIMD is done by:</p><ul>
<li>including the proper header files</li>
<li>replacing <code>float</code> with <code><a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>&lt;float&gt;</code></li>
<li>calling function from namespace <code>eve</code> instead of <code>std</code>.</li>
</ul>
<p >The SIMD version of our conversion functions are then given by:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;eve/wide.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/math.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> rho(<a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x, <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span>  <a class="code hl_variable" href="group__core_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">eve::sqrt</a>(x * x + y * y);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> theta(<a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x, <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="group__math_gaa4476e86ad2d63ed1ee057fb3bc30354.html#gaa4476e86ad2d63ed1ee057fb3bc30354">eve::atan2</a>(y, x);</div>
<div class="line">}</div>
<div class="ttc" id="astructeve_1_1wide_html"><div class="ttname"><a href="structeve_1_1wide.html">eve::wide</a></div><div class="ttdoc">Wrapper for SIMD registers.</div><div class="ttdef"><b>Definition:</b> wide.hpp:64</div></div>
</div><!-- fragment --><p ><a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> behaves like a regular type and can just be dropped as a replacement for any C++ arithmetic types.</p>
<h1><a class="anchor" id="autotoc_md2240"></a>
Handling eve::wide</h1>
<p >The remaining question is how to put data inside an instance of <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> so we can write tests for our SIMD cartesian to polar conversion function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> check_polar()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x1{4};</div>
<div class="line">  <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y1{[](<span class="keyword">auto</span> <a class="code hl_variable" href="group__complex_ga8c06f86a8cb42562fa92a5873424d5e2.html#ga8c06f86a8cb42562fa92a5873424d5e2">i</a>, auto ) { <span class="keywordflow">return</span> 1.5f*(<a class="code hl_variable" href="group__complex_ga8c06f86a8cb42562fa92a5873424d5e2.html#ga8c06f86a8cb42562fa92a5873424d5e2">i</a>+1); }};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; x1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y1 &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; rho(x1,y1) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">float</span> data[] = {1.5f, 3, 4.5f, 6, 7.5f, 9, 10.5f, 12, 13.5, 15, 16.5, 18, 19.5, 21, 22.5, 24};</div>
<div class="line">  <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y2{&amp;data[0]};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; x1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y2 &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; theta(x1,y2) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__complex_ga8c06f86a8cb42562fa92a5873424d5e2_html_ga8c06f86a8cb42562fa92a5873424d5e2"><div class="ttname"><a href="group__complex_ga8c06f86a8cb42562fa92a5873424d5e2.html#ga8c06f86a8cb42562fa92a5873424d5e2">eve::i</a></div><div class="ttdeci">constexpr callable_i_ i</div><div class="ttdoc">Callable object computing the pure imaginary ( ) value.</div><div class="ttdef"><b>Definition:</b> i.hpp:51</div></div>
</div><!-- fragment --><p >There, we construct three instances of <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> using three different constructors:</p>
<ul>
<li><code>x1</code> is constructed from a single scalar value. The result is a register with a 4 in every lane.</li>
<li><code>y1</code> is constructed from a callable object taking two parameters. The first parameter is the current lane to compute, the second is the actual width of the register. The callable object is called once per lane with the corresponding lane index. Here, we use a lambda function that store <code>1.5 * (1 + i)</code> in the \(i^{th}\) lane.</li>
<li><code>y2</code> is constructed from a pointer to <code>float</code>. This will perform a memory-to-register transfer and read <code><a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>&lt;float&gt;::size()</code> contiguous elements starting from <code>&amp;data[0]</code>.</li>
</ul>
<p >An important detail is to note that neither the <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a> type nor any of those constructors requires an <em>a priori</em> knowledge of the actual CPU architecture nor the actual number of lane in the register. This architecture-agnostic style is the main advantage of <b>EVE</b> as it guarantees the portability of the code.</p>
<p >Let's compile this small test using g++:</p>
<div class="fragment"><div class="line">g++ intro-01.cpp -O3 -DNDEBUG -I/path/to/<a class="code hl_namespace" href="namespaceeve.html">eve</a></div>
<div class="ttc" id="anamespaceeve_html"><div class="ttname"><a href="namespaceeve.html">eve</a></div><div class="ttdef"><b>Definition:</b> all_of.hpp:23</div></div>
</div><!-- fragment --><p >By default, if you're compiling on a Intel X86_64 machine, the SSE2 SIMD extension set will be used by the compiler. Under SSE2, SIMD register of <code>float</code> have four lanes. So the expected result is:</p>
<div class="fragment"><div class="line">(4, 4, 4, 4) (1.5, 3, 4.5, 6) =&gt; (4.272, 5, 6.0208, 7.2111)</div>
<div class="line">(4, 4, 4, 4) (1.5, 3, 4.5, 6) =&gt; (0.358771, 0.643501, 0.844154, 0.982794)</div>
</div><!-- fragment --><p >But what if we want to use a SIMD extension with larger registers, say AVX2 for example? In this case, you need to pass the appropriate option to your compiler. For g++, this means using <code>-mavx2</code>.</p>
<div class="fragment"><div class="line">g++ intro-01.cpp -O3 -DNDEBUG -mavx2 -I/path/to/<a class="code hl_namespace" href="namespaceeve.html">eve</a></div>
</div><!-- fragment --><p >As AVX2 registers are twice as big, the output should now contains 8 values:</p>
<div class="fragment"><div class="line">(4, 4, 4, 4, 4, 4, 4, 4) (1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12) =&gt; (4.272, 5, 6.0208, 7.2111, 8.5, 9.84886, 11.2361, 12.6491)</div>
<div class="line">(4, 4, 4, 4, 4, 4, 4, 4) (1.5, 3, 4.5, 6, 7.5, 9, 10.5, 12) =&gt; (0.358771, 0.643501, 0.844154, 0.982794, 1.08084, 1.15257, 1.20682, 1.24905)</div>
</div><!-- fragment --><p >As expected, <b>EVE</b> code scales naturally with the selected architecture at compile time.</p>
<h1><a class="anchor" id="autotoc_md2241"></a>
Mathematical Epilogue</h1>
<p >As stated earlier, we are currently using a slightly brutal computation for \(\rho\). Indeed, if the magnitudes of <code>x</code> and <code>y</code> vary greatly, we may end up with overflow or cancellation, both classic IEEE 754 floating-point issues.</p>
<p >Computing the square root of the sum of the squares of x and y, without undue overflow or underflow at intermediate stages of the computation is the job of a very specific function: <code>std::hypot</code>. Quite handily, <b>EVE</b> also proposes a SIMD implementation via <a class="el" href="group__math_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9" title="Callable object computing the hypot operation.">eve::hypot</a>.</p>
<p >A better implementation is then given as:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;eve/wide.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/math.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> better_rho(<a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> x, <a class="code hl_struct" href="structeve_1_1wide.html">eve::wide&lt;float&gt;</a> y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span>  <a class="code hl_variable" href="group__math_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a>(x, y);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__math_ga1f3f9f62c04251ff83111a058c2e64b9_html_ga1f3f9f62c04251ff83111a058c2e64b9"><div class="ttname"><a href="group__math_ga1f3f9f62c04251ff83111a058c2e64b9.html#ga1f3f9f62c04251ff83111a058c2e64b9">eve::hypot</a></div><div class="ttdeci">constexpr callable_hypot_ hypot</div><div class="ttdoc">Callable object computing the hypot operation.</div><div class="ttdef"><b>Definition:</b> hypot.hpp:92</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2242"></a>
Conclusion</h1>
<p >In this first tutorial, we managed to:</p><ul>
<li>get familiar with <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a>, the main SIMD enabling type from <b>EVE</b></li>
<li>take a simple scalar operation and turn it into a SIMD function using <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a></li>
<li>compile the code for various platform and checks the results.</li>
<li>be aware of the architecture agnostic style of coding with <a class="el" href="structeve_1_1wide.html" title="Wrapper for SIMD registers.">eve::wide</a></li>
</ul>
<p ><a class="el" href="intro-02.html">In the next tutorial</a>, we will use this SIMD function as it should by applying it over multiple data. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.20-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</body>
</html>
