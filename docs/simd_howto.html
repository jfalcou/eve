<!--
  EVE -  Expressive Vector Engine
  Copyright 2020 Joel FALCOU
  Copyright 2020 Jean-Thierry LAPRESTE

  Licensed under the MIT License <http://opensource.org/licenses/MIT>.
  SPDX-License-Identifier: MIT
 -->
<meta charset="utf-8" lang="en"><style class="fallback">body{visibility:hidden;}</style>
                      **Expressive Vector Engine**
                        SIMD howto

  (insert crumbs.html here)

Generalities
====================================================================================================

Nowadays, of the shelf, all computers avalaible on the market propose set of SIMD
instructions at the processor level.

These instruction are reputed to act on N (architecture dependent integer greater than 1) scalar values
in the same way and time are their pure scalar equivalent (conceptualy N=1).

Some programming languages (as *C++*) provide access to so-called `compiler intrinsics` that are mere
functions that allow using the SIMD instructions without writing any assembly code.

Unhappily, these intrinsics depend on the processor brand and type. The aim of *EVE* is to provide a unified
approach to all these processor dependent intrinsics while enabling generating code of performances at par with
hand made optimized assembly performances.

Ideally if the `SIMD vectors` have N scalar elements, one could hope a transformed program to be
 executed N-times faster.
Alas this ratio can not be exactly reached mainly because programs can have:

  * branches
  * order dependancies on data processing

Now if you are used to write SISD (Single Instruction Single Data!) programs, there are some fundamental
principles and tricks to convert these to a vectorized version.

We will give here three commented examples to demonstrate this process and try to avoid the biggest pitfalls.


Trivial example
====================================================================================================

Let us assume we have the following function in a `poleval.hpp` file that evaluates
a polynomial whose coefficient are given in a std::array of values `a` at a value `x`.


<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   #include<array>
   template<typename T, size_t M, typename U>
   auto poleval(std:array<T,M>  a, U x)
   {
     auto r=T(0);
     for(size_t i=0, i<M ++i)
     {
       r+=r*x+a[i];
     }
     return r;
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

What must be done to transform this function in a SIMD function capable to evaluate a polynomial
on a SIMD vector of values ? Here just nothing if we want to keep a scalar polynomial : just use
the function with `x` being a `eve::wide<`T`>`.

However, this is not the current wished situation. Generally the polynomial will be evaluated elementwise on
the elements of another `array`. The good way to do that (without simd) is to use the STL algorithms.


<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   // scalar version
   #include<poleval.hpp>
   #include<array>
   #include<algorithm>

   int main()
   {
     std::array<float,7> a{1,2,3,4,5,6,7};
     auto doit = [&a](auto x){ return poleval(a,x); };
     std:transform(a.begin(), a.end(), r.begin(), doit);
     auto printit = [](auto x){ std::cout<< x << std::endl;};
     std:for_each(r.begin(), r.end(), printit);
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   // simd version
   #include<poleval.hpp>
   #include<array>
   #include<algorithm>
   #include<eve/function/transform.hpp>

   int main()
   {
     std::array<float,8> a{1,2,3,4,5,6,7,8};
     auto doit = [&a](auto x){ return poleval(a,x); };
     eve:transform(a.begin(), a.end(), r.begin(), doit);
     auto printit = [](auto x){ std::cout<< x << std::endl; };
     std:for_each(r.begin(), r.end(), printit);
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

The only difference is replacing here std::transform by eve::transform and including the corresponding file.
In fact as soon as `poleval` is capable of taking SIMD inputs its use through algorithms similar to STL ones
and implemented in eve does not need any knowledge of the SIMD background and will speed the execution by a near N factor.

Now we will investigate what has to be done in a function involving branches to make it usable in SIMD context.


Branching considerations
====================================================================================================

IN SISD contexts the `if else` close is used to choose a computational path according to a test.

For instance, to compute the maximum of two values:


<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++

   template<typename T> auto maxi(T a, T b)
   {
     if (a < b) return b; else return a;
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

or

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++

   template<typename T> auto maxi(T a, T b)
   {
     return a < b ? b : a;
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

These forms share the property that at each call only one branch is taken.
in SIMD context, using *EVE* one can write:


<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++

   template<simd_value T> auto maxi(T a, T b)
   {
     eve::if_else(a < b, b, a);
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

and this is a good use of eve::if_else (we will explain latter what are the bad uses).
The difference is that as `a` and `b` are `simd_value` here `a < b` is not a `bool` but a `logical<`T`>`,
that is conceptually a SIMD vector of true/false and according to the actual values of `a` and `b`,
during the same call both `if` and `else` branches can be taken.

This means that during the process all branches are evaluated and a selection is made thereafter.

For `maxi`, this has no bad consequences as `a` and `b` are vector registers and so there evaluation is almost costless
, all the cost being on a quite quick selection process. But if one consider another function that
return `exp(x)` if `x` is greater than `0` and `exp(2*x)` if `x` is less or equal to `0`:


<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   // scalar version
   template<typename T> auto maxi(T a, T b)
   {
     return x>0 ? exp(2*x) : exp(x);
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

an simd version:

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   // simd version
   template<floating_simd_value T> auto maxi(T a, T b)
   {
     return eve::if_else(x>0 ? eve::exp(2*x) : eve:exp(x));
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

will be suboptimal by a ~2 factor as both `eve::exp(2*x)` and `eve:exp(x)` will be evaluated at each call.
A better version being:

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   // simd version
   template<floating_simd_value T> auto maxi(T a, T b)
   {
     auto z = eve::exp(x);
     return eve::if_else(x>0 ? z*z : z);
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

as in this case the most costly function `eve::exp` will be called just once.

Of course this trick is not always possible, but another one can be available, that can decrease the
cost.

Horizontal branching trick
====================================================================================================

Often enough the values on which we want to apply a function are quite
 sorted or at least of the same magnitude order.
In these kind of situation we can branch another way.

consider another artificial function that
return `log(x)` if `x` is greater than `0` and `exp(x)` if `x` is less or equal to `0`,
so that the previous trich is not available. We can write this:

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
   // simd version
   template<floating_simd_value T> auto maxi(T a, T b)
   {
     auto test = x>0;
     auto n = eve::nbtrue(test);
     T r(0);
     if (n>0)                                // some values must return log
     {
       r=eve::log(x);
       if (n==T::size()) return r;           // all values were already computed
     }
     return eve::if_else(test ? r, exp(x));  // some exp are stil to compute
   }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

Here `eve::nbtrue` is a function returning the number of true values in the vector, and `T::size()` is obvoiusly
the vector number of elements (N).

With this scheme if all the values are satisfying one branch the other is not evaluated.
Of course this process can be used in case were there is more than two choices as it is current in the evaluation
of special functions for which differnt minimax polynomials are evaluated on separaye inputs intervals.

To put strength on the main points :

 *  **each branching with two heavy parts will quasi divide the SIMD gain by 2**
 *  **horizontal branching can lower that cost if datas fall in less branches that their total number**


Masked calls
====================================================================================================

When a call is of the form `z = if_else(test, heavy(x), value)` it is in a good use of `if_else` and
does not suffer performances penalties. However these call can often be optizimed if heavy is an **EVE**
function object.

Many **EVE** function objects can be called conditionally:

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
     z = eve::if_else(test ? eve::f(x), x);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

can often be writen

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
     z = eve::f[test](x);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

and

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
     z = eve::if_else(test ? eve::f(x), value);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

can often be writen

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
     z eve::f[if_(test).else_(value)](x);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

If not always optimized this is always not worse and is peculiarly related to
masked intrinsics available with some processors architectures.


----------------------------------------------------------------------------------------------------

<!-- End of Document -->
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'medium'};</script>
<link rel="stylesheet" href="eve.css">
<!-- Markdeep: -->
<script src="markdeep.min.js"></script>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
