<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>E.V.E: Handling Multiple Architecture Targets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="godbolt.js"></script>
<script type="text/javascript" src="fragment.js"></script>
<script type="text/javascript" src="paragraph.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
  DoxygenAwesomeFragmentCopyButton.init()
  SendToGodbolt.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="https://github.com/jfalcou/eve" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- BEGIN TITLEAREA-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr  style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">E.V.E
   </div>
   <div id="projectbrief">v2023.02.15</div>
  </td>
 </tr>
   <tr><td colspan="2" style="padding: 20px 0px 0px 0px;">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!--END TITLEAREA -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('multiarch.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Handling Multiple Architecture Targets </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md135"></a>
The Issue</h1>
<p>The <b>EVE</b> library uses compile-time code generation process to ensure a high-level of performance. However, there can be many reasons why your application or library might run on unknown systems. Thus, you may want to be able to write your SIMD kernel once and yet be able to adapt to your end-user's hardware.</p>
<p>A first solution could be to just recompile a given kernel with different architecture settings and link everything. Then, at runtime, use eve::is_supported to choose the correct implementation between the available ones. However, in attempting to solve the problem in this way, you'll face issues as the core of <b>EVE</b> is based on templated callable object, you may end up violating the <a href="https://en.cppreference.com/w/cpp/language/definition">One Definition Rule</a> and end up with a binary containing the incorrect symbols and implementations.</p>
<h1><a class="anchor" id="autotoc_md136"></a>
From static to dynamic dispatch</h1>
<p>A more successful approach is to isolate the various versions of a given kernel into separate dynamic libraries. In this case, no multiple definition can happen. This means to use <b>dynamic libraries</b> to store your code and <b>dynamic loading</b>.</p>
<p>Dynamic loading in itself is a large topic mostly due to its OS specific components so <a href="https://en.wikipedia.org/wiki/Dynamic_loading">a good read on the subject is maybe in order</a>. Once you are acquainted with dynamic loading, let's start building our own SIMD dynamic system.</p>
<h2><a class="anchor" id="autotoc_md137"></a>
Writing the kernel</h2>
<p>Let's write a small function that will consume a pointer to a data block containing <code>float</code> values and the size of the data block to process. Inside this kernel, we'll use some algorithms to vectorise this process.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;eve/module/algo.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/module/core.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/wide.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;span&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> compute_kernel(<span class="keywordtype">float</span>* data, std::size_t size)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; compute with: &quot;</span> &lt;&lt; eve::current_api &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;&gt; eve::wide is: &quot;</span> &lt;&lt; <a class="code hl_function" href="structeve_1_1wide.html#a1d3739186033f12c8fe47755f598b60b">eve::wide&lt;float&gt;::size</a>() &lt;&lt; <span class="stringliteral">&quot; elements large.\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_variable" href="group__algos_gabcfe49a76c53b5567df06523ded73cc0.html#gabcfe49a76c53b5567df06523ded73cc0">eve::algo::transform_inplace</a>( std::span{data,size}</div>
<div class="line">                              , [](<span class="keyword">auto</span> e) { <span class="keywordflow">return</span> <a class="code hl_variable" href="group__core__arithmetic_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">eve::sqrt</a>(e + e * 3); }</div>
<div class="line">                              );</div>
<div class="line">}</div>
<div class="ttc" id="agroup__algos_gabcfe49a76c53b5567df06523ded73cc0_html_gabcfe49a76c53b5567df06523ded73cc0"><div class="ttname"><a href="group__algos_gabcfe49a76c53b5567df06523ded73cc0.html#gabcfe49a76c53b5567df06523ded73cc0">eve::algo::transform_inplace</a></div><div class="ttdeci">constexpr auto transform_inplace</div><div class="ttdoc">same as;</div><div class="ttdef"><b>Definition:</b> transform.hpp:72</div></div>
<div class="ttc" id="agroup__core__arithmetic_ga6745422ee3727af1a6e34182e8efbcb7_html_ga6745422ee3727af1a6e34182e8efbcb7"><div class="ttname"><a href="group__core__arithmetic_ga6745422ee3727af1a6e34182e8efbcb7.html#ga6745422ee3727af1a6e34182e8efbcb7">eve::sqrt</a></div><div class="ttdeci">constexpr auto sqrt</div><div class="ttdoc">Computes the square root of the parameter.</div><div class="ttdef"><b>Definition:</b> sqrt.hpp:73</div></div>
<div class="ttc" id="astructeve_1_1wide_html_a1d3739186033f12c8fe47755f598b60b"><div class="ttname"><a href="structeve_1_1wide.html#a1d3739186033f12c8fe47755f598b60b">eve::wide::size</a></div><div class="ttdeci">static constexpr size_type size() noexcept</div><div class="ttdoc">Size of the wide in number of lanes.</div><div class="ttdef"><b>Definition:</b> wide.hpp:377</div></div>
</div><!-- fragment --><p>The code breaks down this way:</p><ul>
<li>We start by including all the necessary include files for the algorithms, functions and types we will use.</li>
<li>We define the <code>compute_kernel</code> function. This function takes a pointer and a size as parameters and is declared <code>extern "C"</code> to prevent unwanted C++ mangling of the symbol. This is typical for dynamic libraries.</li>
<li>Inside <code>compute_kernel</code>, we display some information about the SIMD API we are using and proceed to the computation. As a quick way to handle the data, we pass a <code>std::span</code> to our algorithm.</li>
</ul>
<p>Nothing special is required except for the <code>extern "C"</code> attribute. If we want to get around this limitation and have a function taking arbitrary C++ types as parameters, there are different strategies. One such strategy is to use the mangled name to export a function returning an array or <a href="http://community.qnx.com/sf/docman/do/downloadDocument/projects.toolchain/docman.root.articles/doc1154">structure containing all the pre-computed functions pointers</a> from the <code>.so</code> library.</p>
<h2><a class="anchor" id="autotoc_md138"></a>
Writing the dynamic function hub</h2>
<p>We now need to write an actual <code>compute</code> function that our users will call. This is the place where most of the OS-dependent code will be written. The example we give is made to work on Linux. For a more OS-independent way to handle dynamic loading, you can have a look at <a href="https://www.gnu.org/software/libtool/manual/html_node/Using-libltdl.html">libltdl</a> or use your preferred OS API.</p>
<p>The code looks like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;eve/forward.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;eve/arch/detection.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;dlfcn.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;span&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> load_kernel()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Load the dynamic library</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> selector = []()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">void</span>* handle = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">if</span>(!handle &amp;&amp; eve::is_supported(eve::avx2)  ) handle = dlopen(<span class="stringliteral">&quot;./libcompute_perfect.so&quot;</span> , RTLD_NOW);</div>
<div class="line">    <span class="keywordflow">if</span>(!handle &amp;&amp; eve::is_supported(eve::sse4_1)) handle = dlopen(<span class="stringliteral">&quot;./libcompute_advanced.so&quot;</span>, RTLD_NOW);</div>
<div class="line">    <span class="keywordflow">if</span>(!handle &amp;&amp; eve::is_supported(eve::sse2)  ) handle = dlopen(<span class="stringliteral">&quot;./libcompute_basic.so&quot;</span>   , RTLD_NOW);</div>
<div class="line">    <span class="keywordflow">return</span> handle;</div>
<div class="line">  }();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> selector;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> compute(std::span&lt;float&gt; data)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Fetch the function pointer from its symbol</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> impl = [](<span class="keyword">auto</span> h)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">using </span>func_t  = void (*)(<span class="keywordtype">float</span>*, std::size_t);</div>
<div class="line">    func_t f = h ? (func_t)(dlsym(h, <span class="stringliteral">&quot;compute_kernel&quot;</span>)) : <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">return</span> f;</div>
<div class="line">  }(load_kernel());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Call the actual implementation</span></div>
<div class="line">  impl(data.data(), data.size());</div>
<div class="line">}</div>
</div><!-- fragment --><p>What is going on inside <code>compute</code> ?</p><ul>
<li><code>load_kernel</code> opens the correct dynamic library depending on the actual SIMD support detected at runtime via eve::is_supported. Notice the names of the .so files, we will go back to those afterward but understand that they are arbitrary. To do so, we use <em>Immediately Invoked Lambda Expressions</em> to perform this initialisation.</li>
<li>Next, we load the <code>compute_kernel</code> symbol from the handle we just loaded. As opening and fetching pointer to symbol can be costly, we will make it so those tasks are done once by storing both results in static variables.</li>
<li>Once everything is loaded and setup, we call the function pointer with the appropriate parameters.</li>
</ul>
<p>Obviously, in realistic settings you would actually care about runtime issues, check that every pointer are non-null, and use functions like <code>dlerror</code> to find out what would have caused an issue. This is left as an exercice for the reader.</p>
<h2><a class="anchor" id="autotoc_md139"></a>
Compiling and Using Dynamic Kernels</h2>
<p>The next part is much more down-to-earth. We need to compile the kernel function inside multiple dynamic libraries with different set of options. Then, we need to compile the main binary. To simplify this process, <b>EVE</b> provides a CMake function named <code>eve_build_variants</code> that you can access directly when using <code>find_package</code> or that can be included manually in your CMake after installing the library via <code>include(eve-multiarch)</code>.</p>
<p>Its synopsis is: </p><div class="fragment"><div class="line">eve_build_variants( NAME &lt;name&gt;</div>
<div class="line">                    TARGET      &lt;target suffix&gt;...</div>
<div class="line">                    OPTIONS     &lt;architecture specific options&gt;...</div>
<div class="line">                    [INTERFACE] &lt;name&gt;</div>
<div class="line">                    [QUIET]</div>
<div class="line">                    SOURCES  &lt;source files&gt;...</div>
<div class="line">                  )</div>
</div><!-- fragment --><p><code>eve_build_variants</code> adds multiple dynamic libraries targets for compiling the source file specified via <code>SOURCES</code>. The generated target will be named by combining the <code>NAME</code> and each of the <code>TARGET</code> suffix. For each suffixes, the corresponding options will be used from [OPTIONS].</p>
<p>Optionally, you can pass an <code>INTERFACE</code> name to be used for compiling each of the targets. Optionally, the <code>QUIET</code> flag will remove error messages.</p>
<p>Once called, <code>eve_build_variants</code>sets up a variable in the current scope named <code>eve_${NAME}_variants</code> that contains the list of target building the shared libraries. It can be used to setup dependencies.</p>
<p>Let's say we want to compile our kernel for SSE2, SSE4.1 and AVX2. The CMake code will be looking like:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.18)</div>
<div class="line">project(eve-multi-arch LANGUAGES CXX)</div>
<div class="line"> </div>
<div class="line">find_package(eve CONFIG REQUIRED)</div>
<div class="line"> </div>
<div class="line">add_library(setup INTERFACE)</div>
<div class="line">target_link_libraries(setup INTERFACE eve::eve)</div>
<div class="line">target_compile_options(setup INTERFACE &quot;-O3&quot;)</div>
<div class="line"> </div>
<div class="line">eve_build_variants( NAME compute</div>
<div class="line">                    INTERFACE   setup</div>
<div class="line">                    TARGET      basic advanced perfect</div>
<div class="line">                    OPTIONS     &quot;-msse2&quot;  &quot;-msse4.1&quot; &quot;-march=haswell&quot;</div>
<div class="line">                    SOURCES     kernel.cpp</div>
<div class="line">                  )</div>
<div class="line"> </div>
<div class="line">add_executable(multi-arch main.cpp compute.cpp)</div>
<div class="line">add_dependencies(multi-arch ${eve_compute_variants})</div>
<div class="line">target_link_libraries(multi-arch PUBLIC setup ${CMAKE_DL_LIBS})</div>
</div><!-- fragment --><p>Let's get into the details:</p><ul>
<li>After the classical CMake basics, we use <code>find_package</code> to grab <b>EVE</b>. Depending on your <b>EVE</b> installation path, you may have to specify <code>CMAKE_PREFIX_PATH</code> for CMake to find it.</li>
<li>We define an INTERFACE library that use the main <b>EVE</b> interface and add some customisation.</li>
<li>We call <code>eve_build_variants</code> to build a set of targets. The base name will be <code>compute</code> and there are three different target suffixes: <code>basic</code>, <code>advanced</code>, <code>perfect</code>. For each of those, the following options will be used: <code>-msse2</code>, <code>-msse4.1</code>, <code>-march=haswell</code>. Each target is compiled with its corresponding options. In the end, we expect three libraries to be compiled: <code>libcompute_basic.so</code>, <code>libcompute_advanced.so</code>, and <code>libcompute_perfect.so</code>. Notice how the suffixes are arbitrary. They just need to correspond to any naming scheme you see fit and those names will have to be used in the dynamic loading function.</li>
<li>To perform this compilation, we use the <code>setup</code> interface we customized earlier.</li>
<li>We add our executable target that just compiles a main file and the compute function. To be sure we don't forget to compile the libraries when we compile the main executable, we use the exported <code>eve_compute_variants</code> macro that contains the list of targets created by <code>eve_build_variants</code>. Because we use <code>dlopen</code>, we need to link with the appropriate library which is conveniently provided by <code>CMAKE_DL_LIBS</code>.</li>
</ul>
<p>That's all. Once generated, this CMake file will let you compile the <code>multi-arch</code> target that will trigger the compilation of the three libraries. Once compiled, the execution of the multi-arch executable will produce some output:</p>
<div class="fragment"><div class="line">Before:</div>
<div class="line">1 2 3 4 5 6 7 8 10 20 30 40 50 60 70 80 90 100 1000 10000</div>
<div class="line">&gt;&gt; compute with: X86 AVX2 (with FMA3 support)</div>
<div class="line">&gt;&gt; eve::wide is: 8 elements large.</div>
<div class="line">After:</div>
<div class="line">2 2.82843 3.4641 4 4.47214 4.89898 5.2915 5.65685 6.32456 8.94427 10.9545 12.6491 14.1421 15.4919 16.7332 17.8885 18.9737 20 63.2456 200</div>
</div><!-- fragment --><p>The complete project is available as in the <code>examples/multi-arch</code> folder. As an exercise, try to modify the code to handle AVX512 and check everything still works.</p>
<h1><a class="anchor" id="autotoc_md140"></a>
Conclusion</h1>
<p>Handling multiple architecture within a single application is not trivial. It requires some scaffolding, much of those being provided by <b>EVE</b> itself at both the CMake and C++ level. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.20-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</div> <!-- DOXYSTRAP RELATED -->
</body>
</html>
